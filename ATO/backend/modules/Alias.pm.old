#!/usr/bin/perl
#---------------------------------------------------------------------------------
# A.Joseph 10-Aug-2015 ++ File: Alias.pm
#---------------------------------------------------------------------------------
# Perl module that creates an alias class. This module calls a constructor to 
# create an alias object that contains alias information stored as object 
# variables.
#
# There exists various subroutines to set alias information, get alias information (to/from objects)
# There exists subroutines that use the Database.pm module to set/get alias information to/from MySQL

package Alias; # Declare package name


use Exporter; # To export subroutines and variables
use Database; # Use our custom database module Database.pm
use Time::Piece; # To parse and convert date time
use Storable qw(dclone); # for deep copies

#---------------------------------------------------------------------------------
# Connect to the database
#---------------------------------------------------------------------------------

my $SQLDatabase		= $Database::targetDatabase;

#====================================================================================
# Constructor for our Alias class 
#====================================================================================
sub new
{
	my $class = shift;
	my $alias = {
		_ser		=> undef,
		_name		=> undef,
	};

	# bless associates an object with a class so Perl knows which package to search for
	# when a method is envoked on this object
	bless $alias, $class; 
	return $alias;
}

#======================================================================================
# Subroutine to set the alias serial
#======================================================================================
sub setAliasSer
{
	my ($alias, $ser) = @_; # alias object with provided serial in arguments
	$alias->{_ser} = $ser if defined($ser); # set the serial
	return $alias->{_ser};
}

#======================================================================================
# Subroutine to set the alias name
#======================================================================================
sub setAliasName
{
	my ($alias, $name) = @_; # alias object with provided name in arguments
	$alias->{_name} = $name if defined($name); # set the name
	return $alias->{_name};
}

#======================================================================================
# Subroutine to get the alias serial
#======================================================================================
sub getAliasSer
{
	my ($alias) = @_; # our alias object
	return $alias->{_ser};
}

#======================================================================================
# Subroutine to get the alias name
#======================================================================================
sub getAliasName
{
	my ($alias) = @_; # our alias object
	return $alias->{_name};
}

#======================================================================================
# Subroutine to get the aliases marked for update
#======================================================================================
sub getAliasesMarkedForUpdate
{
	my @aliasList = (); # initialize our list of alias objects
	my ($ser, $name, $type, $lastupdated);
	my @expressions;

	#======================================================================================
	# Retrieve the alias info
	#======================================================================================
	my $aliasInfo_sql = "
		SELECT DISTINCT
			Alias.AliasSerNum,
			Alias.AliasType,
			Alias.LastUpdated
		FROM
			Alias
		WHERE
			Alias.AliasUpdate	= 1
	";

	# prepare query
	my $query = $SQLDatabase->prepare($aliasInfo_sql)
		or die "Could not prepare query: " . $SQLDatabase->errstr;

	# execute query
	$query->execute()
		or die "Could not execute query: " . $query->errstr;

	while (my @data = $query->fetchrow_array()) {

		my $Alias = new Alias(); # alias object

		$ser		= $data[0];
		$type		= $data[1];
		$lastupdated	= $data[2];

		# set alias information
		$Alias->setAliasSer($ser);
		$Alias->setAliasType($type);
		$Alias->setAliasLastUpdated($lastupdated);

		# get expressions for this alias
		@expressions	= $Alias->getAliasExpressionsFromOurDB();

		# finally, set expressions 
		$Alias->setAliasExpressions(@expressions);

		push(@aliasList, $Alias);
	}

	return @aliasList;
}


#======================================================================================
# Subroutine to get the expressions for a particular alias from MySQL
#======================================================================================
sub getAliasExpressionsFromOurDB
{
	my %expressions = (); # initialize a list of expressions

	#======================================================================================
	# Retrieve the alias expressions
	#======================================================================================
	my $expressionInfo_sql = "
		SELECT DISTINCT
			AliasExpression.AliasExpressionSerNum,
			AliasExpression.ExpressionName
		FROM 
			Alias,
			AliasExpression
		WHERE
			Alias.AliasUpdate		= 1
		AND 	AliasExpression.AliasSerNum	= Alias.AliasSerNum
	";

	# prepare query
	my $query = $SQLDatabase->prepare($expressionInfo_sql)
		or die "Could not prepare query: " . $SQLDatabase->errstr;

	# execute query
	$query->execute()
		or die "Could not execute query: " . $query->errstr;

	while (my @data = $query->fetchrow_array()) {
        $expressions{$data[1]} = $data[0];

    }
	return %expressions;
}

#======================================================================================
# Subroutine to check if our expression exists in our MySQL db
#	@return: expression object (if exists) .. NULL otherwise
#======================================================================================
sub inOurDatabase
{
	my ($expression) = @_; # our alias object
	my $expressionname = $expression->getAliasName(); # retrieve serial

	my $ExpressionNameInDB = 0; # false by default. Will be true if expression exists
	my $ExistingExpression = (); # data to be entered if expression exists

	my $ser;

	my $inDB_sql = "
		SELECT DISTINCT
			AliasExpression.AliasExpressionSerNum,
			AliasExpression.ExpressionName
		FROM 
			AliasExpression
		WHERE
			AliasExpression.ExpressionName = \"$expressionname\"
	";

	# prepare query
	my $query = $SQLDatabase->prepare($inDB_sql)
		or die "Could not prepare query: " . $SQLDatabase->errstr;

	# execute query
	$query->execute()
		or die "Could not execute query: " . $query->errstr;

	while (my @data = $query->fetchrow_array()) {
		
		$ser			= $data[0];
		$ExpressionNameInDB	= $data[1];
	}

	if ($ExpressionNameInDB) {
		
		$ExistingExpression = new Alias(); # initialize object

		$ExistingExpression->setAliasSer($ser);
		$ExistingExpression->setAliasName($ExpressionNameInDB);

		return $ExistingExpression; # this is true (ie. expression exists) return object
	}

	else {return $ExistingExpression;} # this is false (ie. expression DNE) return empty
}

#======================================================================================
# Subroutine to insert our expression in our database
#======================================================================================
sub insertAliasExpressionIntoOurDB
{

	my ($expression) = @_; # our alias object

	my $name	= $expression->getAliasName();

	# insert
	my $insert_sql = "
		INSERT INTO
			AliasExpression (
				AliasExpressionSerNum,
				ExpressionName,
				LastUpdated
			)
		VALUES (
			NULL,
			\"$name\",
			NULL
		)
	";

	# prepare query
	my $query = $SQLDatabase->prepare($insert_sql)
		or die "Could not prepare query: " . $SQLDatabase->errstr;

	# execute query
	$query->execute()
		or die "Could not execute query: " . $query->errstr;

	# Retrieve the serial
	my $ser = $SQLDatabase->last_insert_id(undef, undef, undef, undef);

	# Set the Serial in our alias object
	$expression->setAliasSer($ser);

	return $expression;
	
}

#======================================================================================
# Subroutine to reassign an expression name in ARIA to an expression serial in MySQL. 
# In the process, insert expression into our database if it DNE
#======================================================================================
sub reassignExpression
{
	my ($expressionName) = @_; # expression name in args
	
	my $AliasExpression = new Alias(); # initialize alias object

	$AliasExpression->setAliasName($expressionName); # assign our expression

	# check if our expression exists in our database
	my $ExpressionExists = $AliasExpression->inOurDatabase();

	if ($ExpressionExists) {

		my $ExistingExpression = dclone($ExpressionExists); # reassign variable

		my $expressionSerNum = $ExistingExpression->getAliasSer(); # get serial

		return $expressionSerNum;
	}
	else {# expression DNE

		# insert expression into our database
		$AliasExpression = $AliasExpression->insertAliasExpressionIntoOurDB();

		# get serial
		my $expressionSerNum = $AliasExpression->getAliasSer();

		return $expressionSerNum;
	}
}

